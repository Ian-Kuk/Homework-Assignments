# -*- coding: utf-8 -*-
"""ENGR2995 - Homework 02 - NumPy Pandas and Matplotlib.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XtTm3RKia_kqRPpDML7BjOMGVfTMZ7D7
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""# NumPy, Pandas, and Matplotlib

Here we outlines techniques for effectively loading, storing, and manipulating in-memory data in Python. Machine learning datasets can come from a wide range of sources and a wide range of formats, including documents, images, sound recording, scientific measurements, or nearly anything else. Despite this apparent heterogeneity, it will help us to think of all data fundamentally as arrays of numbers.

For example, images can be thought of as simply two-dimensional arrays of numbers representing pixel brightness across the area. Sound clips can be thought of as one-dimensional arrays of intensity versus time. Text can be converted in various ways into numerical representations. No matter what the data are, the first step in making it analyzable will be to transform them into arrays of numbers.

For this reason, efficient storage and manipulation of numerical arrays is  fundamental to the process of doing machine learning. We'll now take a look at the specialized tools that Python has for handling and visualizing such numerical arrays: the NumPy package, the Pandas package, and the Matplotlib package.

## 1. NumPy

NumPy (short for Numerical Python) provides an efficient interface to store and operate on dense data buffers. In some ways, NumPy arrays are like Python's built-in `lis`t type, but NumPy arrays provide much more efficient storage and data operations as the arrays grow larger in size. NumPy arrays form the core of nearly the entire ecosystem of machine learning tools in Python, so time spent learning to use NumPy effectively will be valuable.
"""

# we import the numpy module and set an alias for numpy as "np"
import numpy as np

#Documentation: numpy.org

# uncomment to view the "namespace" or list of all possible functions and attributes
#dir(np)

# uncomment to view built-in documentation
# help(np)

"""### Creating arrays from python lists

A python list can be converted to a numpy array by passing the list into the `np.array()` function. Unlike python lists, a numpy array must have a uniform data type. When passing in a python list containing multiple data types, each element of the list is cast to the most "permissive" data type.
"""

# creating an array from a list
a = np.array([1, 4, 2, 5, 3])
print(a)

# creating an array from a list of mixed data types
a = np.array([3.14, 4, 2, 3])
print(a.dtype, a)

# explicitly setting the data type or dtype
# float32 is a 32-bit floating point value
a = np.array([1, 2, 3, 4], dtype='float32')
print(a)

# creating an 2-D array from a nested list
a = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])
print(a)

# creating the same 2-D array as above but with a list comprehension
a = np.array([range(i, i+3) for i in [1, 4, 7]])
print(a)

"""### Creating arrays from scratch"""

# a 1-D array of 5 zeros with integer data type
a = np.zeros(5, dtype=int)
print(a)

# a 2-D array of 3x5 (3 rows, 5 columns) ones with float data type
a = np.ones((3, 5), dtype=float)
print(a)

# a 2-D array of 2x2 (2 rows, 2 columns) values
a = np.full((2, 2), 3.14)
print(a)

# an ordered set of integers from 0 (inclusive) to 10 (exclusive) counting by 2's
a = np.arange(0, 10, 2) # note the similarity to built-in python `range()`
print(a)

# a continuous ordered set from 0 (inclusive) to 1 (inclusive) broken into 5 equally-spaced data points
a = np.linspace(0, 1, 5) # note the syntax differences compared to `np.arange()`
print(a)

# a 2-D array of 2x2 numbers sampled from the uniform distribution [0, 1) (0 inclusive, 1 exclusive)
a = np.random.random((2, 2))
print(a)

# a 2-D array of 2x2 numbers sampled from the normal distribution with 0 mean and unit standard deviation N(0, 1)
a = np.random.normal(0, 1, (2, 2))
print(a)

# a 2-D array of 2x2 numbers sample from a uniform distribution of integers from 0 (inclusive) to 10 (exclusive)
a = np.random.randint(0, 10, (2, 2))
print(a)

# a square, 2x2 identity matrix
a = np.eye(2)
print(a)

"""### Array attributes

Every array has descriptive attributes for computing dimensionality and data types.
"""

x = np.random.randint(0, 10, (3,4,5))

# np.ndarray.ndim gives the number of dimension of the array (i.e. 0 for scalar, 1 for vector, 2 for matrix, ..)
print(x.ndim)

# np.ndarray.size gives the number elements on the array
print(x.size)

# np.ndarray.size gives the size of each individual dimension
print(x.shape)

# np.ndarray.dtype gives the datatype of the array
print(x.dtype)

# np.ndarray.nbytes gives the size of the array in bytes
print(x.nbytes)

"""### Indexing and slicing

Indexing ndarrays works similar to indexing Python list objects. In a one-dimensional array, the i-th value (counting from zero) can be accessed by specifying the desired index in square brackets. In a multi-dimensional array, items can be accessed using a comma-separated tuple of indices. We can use indexing operations to modify existing values in an array.
"""

# a one-dimensional array
x1 = np.array([5, 0, 3, 3, 7, 9])

# indexing from zero
print(x1[0], x1[4])

# indexing from the back
print(x1[-1], x1[-2])

# a two-dimensional array
x2 = np.array([[1, 2, 3],
               [4, 5, 6],
               [7, 8, 9]])

# print element in row=0, column=0 and row=2 column=0
print(x2[0, 0], x2[2, 0])

# print element in row=2, column=-1 and row=-1, column=-1
print(x2[2, -1], x2[-1, -1])

# assign a value
x1[0] = 3.14159

# watch out! values set by re-assignment are
# automatically casted to the data type of the original array
print(x1)

x1[0:x1.shape[0]:1]

"""We can use Python slice notation to slice along individual dimensions of a ndarray.

```python
x[start:stop:step]
```

If any of these values are unspecified, the default values are `start=0`, `stop=end`, `step=1`.
"""

x = np.arange(10)
print(x)

print(x[:5]) # the first five elements
print(x[5:]) # elements after index 5
print(x[4:7]) # elements after index 4 up to 7
print(x[::2]) # every other element
print(x[1::2]) # every other element starting at index 1
print(x[::-1]) # reversed array
print(x[5::-2]) # revered, every other element starting at index 5

x2 = np.random.randint(0, 10, size=(3, 4))
print(x2)

print(x2[:2, :3]) # two rows, three columns
print(x2[:3, ::2]) # three rows, every other column
print(x2[::-1, ::-1]) # reversed
print(x2[:, 0]) # first column of x2
print(x2[0, :]) # first row of x2
print(x2[0]) # first row of x2, shorthand

"""It's important to note that sliced subarrays are simply references to particular values in the parent array. This means that modifying the value of a subarray will change the corresponding value in the parent array. We can make a `copy()` of the subarray to prevent modifying the parent array."""

x2_sub = x2[:2, :2]
print(x2_sub)

x2_sub[0, 0] = 99
print(x2_sub)

# The 0,0 element of x2 is also modified
print(x2)

x2_sub_copy = x2[:2, :2].copy()
print(x2_sub_copy)

x2_sub_copy[0, 0] = 42
print(x2_sub_copy)

# The 0,0 element of x2 remains unmodified
print(x2)

"""### Reshaping

Another useful operation is the reshaping of arrays. Note that the size of the initial array must match the size of the reshaped array. The `reshape()` method returns a view (not a copy!) of the original data. We can create a new dimension using the `np.newaxis` keyword in a slicing operation.
"""

# a 1-D array
x = np.array([1, 2, 3])

# a row vector via reshape
print(x.reshape((1, 3)))

# we can also infer the size of a single dimension
# using a "-1" in the slicing operation
print(x.reshape((1, -1)))

# a row vector via newaxis
print(x[np.newaxis, :])

# a column vector via reshape
print(x.reshape((3, 1)))

# a column vector via newaxis
print(x[:, np.newaxis])

"""### Concatenating and splitting

It is possible to combine multiple arrays into one, or to split a single arrays into multiple arrays. We can use `np.concatenate` to combine a list of arrays along an existing dimension. We can use `np.stack` to combine a list of arrays along a new dimension that we create. We can split an array using the `np.split` function.
"""

x = np.array([1, 2, 3])
y = np.array([4, 5, 6])
z = np.array([7, 8, 9])

# concatenate along the 0-th dimension
print(np.concatenate([x, y, z], axis=0))

# stack along the 0-th dimension (vectors are stacked row-wise)
print(np.stack([x, y, z], axis=0))

# stack along the 1-st dimension (vectors are stacked column-wise)
print(np.stack([x, y, z], axis=1))

z = np.array([1, 2, 3, 99, 99, 3, 2, 1])
# split the array at particular indices given in list
z1, z2, z3 = np.split(z, [3, 5])
print(z1, z2, z3)

"""### Universal functions

Universal functions rapidly operate on array values. Base Python is a dynamic, interpreted language, and the fact that variable types are flexible (sometimes a good thing!) prevents the compilation of efficient machine code for sequences of operations. This can be seen where many small operations are repeated, like looping over a list and operating on individual elements.
"""

big_list = [1 for _ in range(1000000)] # one million ones
big_array = np.array(big_list)

# Commented out IPython magic to ensure Python compatibility.
# %timeit sum(big_list)

# Commented out IPython magic to ensure Python compatibility.
# %timeit np.sum(big_array)

"""NumPy contains compiled routines of common array operations, known as vectorized operations. These operation, when applied to an array, apply the same operation to each element of an array. These operations call compiled C code that exist under-the-hood of NumPy and gives much faster execution.

You can find a list of [NumPy Universal Functions](https://numpy.org/doc/stable/reference/ufuncs.html) and [SciPy Universal Functions](https://docs.scipy.org/doc/scipy/reference/special.html) online.
"""

# Basic arithmetic
x = np.arange(4)
print("x     =", x)
print("x + 5 =", x + 5)
print("x - 5 =", x - 5)
print("x * 2 =", x * 2)
print("x / 2 =", x / 2)
print("x // 2 =", x // 2)  # floor division
print("-x     = ", -x)
print("x ** 2 = ", x ** 2)
print("x % 2  = ", x % 2)

# Trig
theta = np.linspace(0, np.pi, 3)
print("theta      = ", theta)
print("sin(theta) = ", np.sin(theta))
print("cos(theta) = ", np.cos(theta))
print("tan(theta) = ", np.tan(theta))
x = [-1, 0, 1]
print("x         = ", x)
print("arcsin(x) = ", np.arcsin(x))
print("arccos(x) = ", np.arccos(x))
print("arctan(x) = ", np.arctan(x))

# Exponentials and logarithms
x = [1, 2, 3]
print("x     =", x)
print("e^x   =", np.exp(x))
print("2^x   =", np.exp2(x))
print("3^x   =", np.power(3, x))
x = [1, 2, 4, 10]
print("x        =", x)
print("ln(x)    =", np.log(x))
print("log2(x)  =", np.log2(x))
print("log10(x) =", np.log10(x))

# Some special exp/log functions with increased precision for small values
x = [0, 0.001, 0.01, 0.1]
print("exp(x) - 1 =", np.expm1(x))
print("log(1 + x) =", np.log1p(x))

# Aggregation
x = np.arange(10)
print("x          =", x)
print("sum(x)     =", np.sum(x))
print("prod(x)    =", np.prod(x))
print("mean(x)    =", np.mean(x))
print("std(x)     =", np.std(x))
print("var(x)     =", np.var(x))
print("min(x)     =", np.min(x))
print("max(x)     =", np.max(x))
print("argmin(x)  =", np.argmin(x))
print("argmax(x)  =", np.argmax(x))

"""### Comparison operators

Comparison operators work with NumPy arrays. The result of a conditional statement gives an array of boolean (`True`, `False`) values. We can use these boolean arrays create sub-arrays like slicing but based on a condition statement. We can also check whether certain values exist within arrays.
"""

x = np.array([1, 2, 3, 4, 5])

# are the elements of x less than 3?
print(x<3)

# are the elements of x not equal to 3?
print(x!=3)

# index the elements of x where x is less than 3
x[x<3]

# How many elements in x are less than 3?
print(np.sum(x<3))

# Are any elements in x less than 3?
print(np.any(x<3))

# Are all elements in x less than 3?
print(np.all(x<3))

"""### Sorting arrays

There are two typical ways to sort an array. First, we can sort in alpha-numeric order using the `np.sort()` function. Second, we can generate a set of indices that sort an array with `np.argsort()`. When the particular array is indexed by the set of indices, the resulting array is sorted in alpha-numeric order. This is useful when we have two arrays of pair values, say `x` and `y`, and we want to sort one array (`x`) and maintain the one-to-one correspondance of values in a second array (`y`).
"""

x = np.array([2, 1, 4, 3, 5])

print(np.sort(x))

idx = np.argsort(x)
print(idx)
print(x[idx])

"""### Broadcasting

We saw in the previous section how NumPy's universal functions can be used to *vectorize* operations and thereby remove slow Python loops.
Another means of vectorizing operations is to use NumPy's *broadcasting* functionality.
Broadcasting is simply a set of rules for applying binary ufuncs (e.g., addition, subtraction, multiplication, etc.) on arrays of different sizes.

Recall that for arrays of the same size, binary operations are performed on an element-by-element basis:
"""

a = np.array([0, 1, 2])
b = np.array([5, 5, 5])
a + b

"""Broadcasting allows these types of binary operations to be performed on arrays of different sizes–for example, we can just as easily add a scalar (think of it as a zero-dimensional array) to an array:"""

a + 5

"""We can think of this as an operation that stretches or duplicates the value ``5`` into the array ``[5, 5, 5]``, and adds the results.
The advantage of NumPy's broadcasting is that this duplication of values does not actually take place, but it is a useful mental model as we think about broadcasting.

We can similarly extend this to arrays of higher dimension. Observe the result when we add a one-dimensional array to a two-dimensional array:
"""

M = np.ones((3, 3))
M

M + a

"""Here the one-dimensional array ``a`` is stretched, or broadcast across the second dimension in order to match the shape of ``M``.

While these examples are relatively easy to understand, more complicated cases can involve broadcasting of both arrays. Consider the following example:
"""

a = np.arange(3)
b = np.arange(3)[:, np.newaxis]

print(a)
print(b)

a + b

"""Just as before we stretched or broadcasted one value to match the shape of the other, here we've stretched *both* ``a`` and ``b`` to match a common shape, and the result is a two-dimensional array!

![broadcasting.png](data:image/png;base64,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)

The light boxes represent the broadcasted values: again, this extra memory is not actually allocated in the course of the operation, but it can be useful conceptually to imagine that it is.
"""



"""### Rules of Broadcasting

Broadcasting in NumPy follows a strict set of rules to determine the interaction between the two arrays:

- Rule 1: If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is *padded* with ones on its leading (left) side.
- Rule 2: If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.
- Rule 3: If in any dimension the sizes disagree and neither is equal to 1, an error is raised.

To make these rules clear, let's consider a few examples in detail.

#### Broadcasting example 1

Let's look at adding a two-dimensional array to a one-dimensional array:
"""

M = np.ones((2, 3))
a = np.arange(3)

"""Let's consider an operation on these two arrays. The shape of the arrays are

- ``M.shape = (2, 3)``
- ``a.shape = (3,)``

We see by rule 1 that the array ``a`` has fewer dimensions, so we pad it on the left with ones:

- ``M.shape -> (2, 3)``
- ``a.shape -> (1, 3)``

By rule 2, we now see that the first dimension disagrees, so we stretch this dimension to match:

- ``M.shape -> (2, 3)``
- ``a.shape -> (2, 3)``

The shapes match, and we see that the final shape will be ``(2, 3)``:
"""

M + a

"""#### Broadcasting example 2

Let's take a look at an example where both arrays need to be broadcast:
"""

a = np.arange(3).reshape((3, 1))
b = np.arange(3)

"""Again, we'll start by writing out the shape of the arrays:

- ``a.shape = (3, 1)``
- ``b.shape = (3,)``

Rule 1 says we must pad the shape of ``b`` with ones:

- ``a.shape -> (3, 1)``
- ``b.shape -> (1, 3)``

And rule 2 tells us that we upgrade each of these ones to match the corresponding size of the other array:

- ``a.shape -> (3, 3)``
- ``b.shape -> (3, 3)``

Because the result matches, these shapes are compatible. We can see this here:
"""

a + b

"""#### Broadcasting example 3

Now let's take a look at an example in which the two arrays are not compatible:
"""

M = np.ones((3, 2))
a = np.arange(3)

"""This is just a slightly different situation than in the first example: the matrix ``M`` is transposed.
How does this affect the calculation? The shape of the arrays are

- ``M.shape = (3, 2)``
- ``a.shape = (3,)``

Again, rule 1 tells us that we must pad the shape of ``a`` with ones:

- ``M.shape -> (3, 2)``
- ``a.shape -> (1, 3)``

By rule 2, the first dimension of ``a`` is stretched to match that of ``M``:

- ``M.shape -> (3, 2)``
- ``a.shape -> (3, 3)``

Now we hit rule 3–the final shapes do not match, so these two arrays are incompatible, as we can observe by attempting this operation:
"""

# uncomment below to see the error message
# M + a

"""Note the potential confusion here: you could imagine making ``a`` and ``M`` compatible by, say, padding ``a``'s shape with ones on the right rather than the left.
But this is not how the broadcasting rules work!
That sort of flexibility might be useful in some cases, but it would lead to potential areas of ambiguity.
If right-side padding is what you'd like, you can do this explicitly by reshaping the array (we'll use the ``np.newaxis`` keyword):
"""

a[:, np.newaxis].shape

M + a[:, np.newaxis]

"""Also note that while we've been focusing on the ``+`` operator here, these broadcasting rules apply to *any* binary ``ufunc``.
For example, here is the ``logaddexp(a, b)`` function, which computes ``log(exp(a) + exp(b))`` with more precision than the naive approach:
"""

np.logaddexp(M, a[:, np.newaxis])

"""#### Example: Centering an array

In the previous section, we saw that ufuncs allow a NumPy user to remove the need to explicitly write slow Python loops. Broadcasting extends this ability.
One commonly seen example is when centering an array of data.
Imagine you have an array of 10 observations, each of which consists of 3 values.
Using the standard convention, we'll store this in a $10 \times 3$ array:
"""

X = np.random.random((10, 3))

"""We can compute the mean of each feature using the ``mean`` aggregate across the first dimension:"""

Xmean = np.mean(X, axis=0)
Xmean

"""And now we can center the ``X`` array by subtracting the mean (this is a broadcasting operation):"""

X_centered = X - Xmean

"""To double-check that we've done this correctly, we can check that the centered array has near zero mean:"""

X_centered.mean(0)

"""#### Example: Plotting a two-dimensional function

One place that broadcasting is very useful is in displaying images based on two-dimensional functions.
If we want to define a function $z = f(x, y)$, broadcasting can be used to compute the function across the grid:
"""

# x and y have 50 steps from 0 to 5
x = np.linspace(0, 5, 50)
y = np.linspace(0, 5, 50)[:, np.newaxis]

z = np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)

"""We'll use Matplotlib to plot this two-dimensional array:"""

plt.imshow(z, origin='lower', cmap='viridis')
plt.colorbar()

"""## 2. Pandas

Pandas is a powerful tool for data analysis and manipulation. We will use Pandas to load data from files. We will use Pandas to do basic data manipulation. But, ultimately, Pandas provides us a way to easily create NumPy based datasets from files.
"""

# import pandas and alias to "pd"
import pandas as pd

# Documentation: pandas.pydata.org

# uncomment to view the "namespace" or list of all possible functions and attributes
# dir(pd)

# uncomment to view built-in documentation
# help(pd)

"""### Constructing a Series object

A pandas `Series` is an indexed, one-dimensional array with flexible indices. We can construct a `Series` object using "data" (python list, dictionary, numpy array, ..) and optionally an "index" (a set of identifier used to retreive values from the series). In the absense of an index, an ordered range object is used instead.
"""

# creating a series with a list
data = pd.Series([0.25, 0.5, 0.75, 1.0])
data

print(data.values)

print(data.index)

print(data[1:3])

# creating a series with a dictionary listing the population of 5 states
population_dict = {'California': 38332521,
                   'Texas': 26448193,
                   'New York': 19651127,
                   'Florida': 19552860,
                   'Illinois': 12882135}
population = pd.Series(population_dict)
population

population

print(population.values)

print(population.index)

print(population['California'])

print(population['Texas':'Florida'])

"""### Constructing a Dataframe

The `DataFrame` is an analog of a two-dimensional array with flexible row indices and flexible column indices. You can also think of a `DataFrame` as a collection of `Series` objects that share a common index.
"""

# Construct a `Series` listing the area of five states
area_dict = {'California': 423967, 'Texas': 695662, 'New York': 141297,
             'Florida': 170312, 'Illinois': 149995}
area = pd.Series(area_dict)
area

# Construct a `DataFrame` from a dictionary of `Series` objects
states = pd.DataFrame({'population': population,
                       'area': area})
states

# Indexing a particular column, 'area'
states['area']

# Constructing a DataFrame from a list of dictionaries
data = [{'a': i, 'b': 2 * i}
        for i in range(3)]
pd.DataFrame(data)

# Constructing a DataFrame from a 2-D NumPy array
data = pd.DataFrame(np.random.rand(3, 2),
             columns=['foo', 'bar'],
             index=['a', 'b', 'c'])
data

# Swap the row/columns of a DataFrame
data.T

# Loading a DataFrame from a .csv file
pd.read_csv('sample_data/california_housing_train.csv')

# Loading a DataFrame from a .json file
pd.read_json('sample_data/anscombe.json')

"""### Converting to NumPy

DataFrames can be converted to NumPy arrays by accessing the `pd.DataFrame.values` attribute.
"""

data.values

"""### Indexing

Sub-DataFrames can be constructed by indexing operations on DataFrames. There are two ways of locating data within a DataFrame: using the `pd.DataFrame.iloc` attribute or using the `pd.DataFrame.loc` attribute. The `iloc` attribute allows NumPy-like slicing by numeric indices. The `loc` attribute uses the row/column names for slicing operations. We can use indexing operations to reassign values within a DataFrame.
"""

# first two rows, first column
data.iloc[:2, :1]

# same as above, but using row/column index values
data.loc[:'b', :'foo']

# variable reassignment
data.iloc[0, 1] = 2.0
data

"""### Handling missing data

Missing data is given an assigned value of `NaN`, or "Not a Number". In Python, `NaN` values are indicated by the value `None` or in NumPy `np.nan`. `NaN` values wreck normal NumPy operations. We use specialized NumPy operations to deal with data that potentially contain missing values.
"""

v = np.array([1, np.nan, 3, 4])
v

1 + np.nan

print(np.sum(v), np.min(v), np.max(v))

print(np.nansum(v), np.nanmin(v), np.nanmax(v))

"""### Operating on null values

- `pd.DataFrame.isnull()` generates Boolean mask of missing values
- `pd.DataFrame.notnull()` generates the opposite of `isnull()`
- `pd.DataFrame.dropna()` returns filtered version of data
- `pd.DataFrame.fillna()` returns a copy of the data with missing values filled
"""

data = pd.DataFrame([[1, None, 3], [4, 5, 6], [None, 8, 9]])
data

data.isnull()

# drop rows that contain NaN values
data.dropna()

# drop columns that contain NaN values
data.dropna(axis=1)

# fill NaN values with "0"
data.fillna(0)

"""### Combining Dataframes

DataFrame can be merged together using the `pd.concat()` operation. DataFrame can be combined by row or by column. There are additional arguments to preserve row index names or to compute new row indicies. For DataFrame with different column indices, we can combine either by union (keep all unique column names) or by intersection (keep only columns names that exist in all DataFrames combined). We can also use `pd.merge()` disjoint DataFrame with useful results.
"""

df1 = pd.DataFrame({'A': ['A1', 'A2'], 'B': ['B1', 'B2']})
df1

df2 = pd.DataFrame({'A': ['A3', 'A4'], 'B': ['B3', 'B4']})
df2

# concatenate df1 and df2 row-wise
pd.concat([df1, df2])

# recompute the row indices
pd.concat([df1, df2], ignore_index=True)

df3 = pd.DataFrame({'C': ['C1', 'C2'], 'D': ['D1', 'D2']})
df3

# combine DataFrame column-wise
pd.concat([df1, df3], axis=1)

data = 'ABC'
ind = range(2)
# this is dictionary-comprehension where the value is given by a list-comprehension
df5 = pd.DataFrame({i:[i+str(j) for j in ind] for i in data})
df5

data = 'BCD'
ind = range(2, 5)
df6 = pd.DataFrame({i:[i+str(j) for j in ind] for i in data})
df6

# union of columns (missing values are NaN)
pd.concat([df5, df6])

# intersection of columns (columns with NaN values are dropped)
pd.concat([df5, df6], join='inner')

employee = ['Bob', 'Jake', 'Lisa', 'Sue']
group = ['HR', 'Engr', 'Engr', 'Acct']
df1 = pd.DataFrame({'employee': employee, 'group': group})
df1

employee = ['Lisa', 'Bob', 'Jake', 'Sue']
hire_date = [2004, 2008, 2012, 2014]
df2 = pd.DataFrame({'employee': employee, 'hire_date': hire_date})
df2

# dataframe in second argument "df2" is sorted to match first argument "df1"
# this is an example of a one-to-one join
df3 = pd.merge(df1, df2)
df3

group = ['Acct', 'Engr', 'HR']
supervisor = ['Ed', 'Carly', 'Steve']
df4 = pd.DataFrame({'group': group, 'supervisor': supervisor})
df4

# This is an example of a many-to-one join
# The information in df4 is repeated as needed
df5 = pd.merge(df3, df4)
df5

"""## 3. Matplotlib"""

# import the matplotlib.pyplot submodule as plt
import matplotlib.pyplot as plt

# documentation: matplotlib.org

# help(plot)

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

"""### The MATLAB-style interface

`Matplotlib` was originally created as a MATLAB plotting replacement for Python users. There exists an interface that should seem familiar to previous MATLAB users.

It is important to note that this interface is stateful: it keeps track of the "current" figure and axes, which are where all `plt` commands are applied. You can get a reference to these using the `plt.gcf()` (get current figure) and `plt.gca()` (get current axes) routines. Use can use `plt.show()` to display the figure in its current state. You can use `plt.close()` to re-initialize the current figure and axes.
"""

plt.figure()  # create a plot figure

# create the first of two panels and set current axis
plt.subplot(2, 1, 1) # (rows, columns, panel number)
plt.plot(x, np.sin(x))

# create the second panel and set current axis
plt.subplot(2, 1, 2)
plt.plot(x, np.cos(x))

"""### The Object-oriented interface

The object-oriented interface is available for these more complicated situations, and for when you want more control over your figure. Rather than depending on some notion of an "active" figure or axes, in the object-oriented interface the plotting functions are methods of explicit `Figure` and `Axes` objects. To re-create the previous plot using this style of plotting, you might do the following:
"""

# First create a grid of plots
# ax will be an array of two Axes objects
fig, ax = plt.subplots(2)

# Call plot() method on the appropriate object
ax[0].plot(x, np.sin(x))
ax[1].plot(x, np.cos(x))

"""### Line plots"""

# empty plot
fig = plt.figure()
ax = plt.axes()

# plot a line using the object-oriented interface
fig = plt.figure()
ax = plt.axes()

x = np.linspace(0, 10, 1000)
ax.plot(x, np.sin(x))

# plot a line using the MATLAB-style interface
plt.plot(x, np.sin(x))

# plot two lines using the MATLAB-stype interface
plt.plot(x, np.sin(x))
plt.plot(x, np.cos(x))

# Adjusting colors
plt.plot(x, np.sin(x - 0), color='blue')        # specify color by name
plt.plot(x, np.sin(x - 1), color='g')           # short color code (rgbcmyk)
plt.plot(x, np.sin(x - 2), color='0.75')        # Grayscale between 0 and 1
plt.plot(x, np.sin(x - 3), color='#FFDD44')     # Hex code (RRGGBB from 00 to FF)
plt.plot(x, np.sin(x - 4), color=(1.0,0.2,0.3)) # RGB tuple, values 0 to 1
plt.plot(x, np.sin(x - 5), color='chartreuse'); # all HTML color names supported

# Adjusting linestyle
plt.plot(x, x + 0, linestyle='solid')
plt.plot(x, x + 1, linestyle='dashed')
plt.plot(x, x + 2, linestyle='dashdot')
plt.plot(x, x + 3, linestyle='dotted');

# For short, you can use the following codes:
plt.plot(x, x + 4, linestyle='-')  # solid
plt.plot(x, x + 5, linestyle='--') # dashed
plt.plot(x, x + 6, linestyle='-.') # dashdot
plt.plot(x, x + 7, linestyle=':');  # dotted

# Adjusting axes limits
plt.plot(x, np.sin(x))
plt.xlim(-1, 11)
plt.ylim(-1.5, 1.5)

# Labeling axes and title
plt.plot(x, np.sin(x))
plt.title("A Sine Curve")
plt.xlabel("x")
plt.ylabel("sin(x)")

# Using a legend
plt.plot(x, np.sin(x), '-g', label='sin(x)')
plt.plot(x, np.cos(x), ':b', label='cos(x)')
plt.axis('equal')
plt.legend()

"""### Scatter plots"""

# Creating a scatter with plt.plot()
x = np.linspace(0, 10, 30)
y = np.sin(x)
plt.plot(x, y, 'o', color='black')

# Marker styles
rng = np.random.RandomState(0)
for marker in ['o', '.', ',', 'x', '+', 'v', '^', '<', '>', 's', 'd']:
    plt.plot(rng.rand(5), rng.rand(5), marker,
             label="marker='{0}'".format(marker))
plt.legend(numpoints=1)
plt.xlim(0, 1.8)

# combining line and scatter plot
plt.plot(x, y, '-p', color='gray',
         markersize=15, linewidth=4,
         markerfacecolor='white',
         markeredgecolor='gray',
         markeredgewidth=2)
plt.ylim(-1.2, 1.2)

# Creating a scatter plot with plt.scatter
plt.scatter(x, y, marker='o')

# The primary difference of plt.scatter from plt.plot is
# that it can be used to create scatter plots where the
# properties of each individual point (size, face color, edge color, etc.)
# can be individually controlled or mapped to data.
rng = np.random.RandomState(0)
x = rng.randn(100)
y = rng.randn(100)
colors = rng.rand(100)
sizes = 1000 * rng.rand(100)

plt.scatter(x, y, c=colors, s=sizes, alpha=0.3,
            cmap='viridis')
plt.colorbar() # show color scale

from sklearn.datasets import load_iris
iris = load_iris()
features = iris.data.T

plt.scatter(features[0], features[1], alpha=0.2,
            s=100*features[3], c=iris.target, cmap='viridis')
plt.xlabel(iris.feature_names[0])
plt.ylabel(iris.feature_names[1])

"""### Error bars"""

# Create a scatter plot with error bars using plt.errorbar
x = np.linspace(0, 10, 50)
dy = 0.8
y = np.sin(x) + dy * np.random.randn(50)

plt.errorbar(x, y, yerr=dy, fmt='.k')

# This shows some additional arguments for controlling the formatting of error bars
plt.errorbar(x, y, yerr=dy, fmt='o', color='black',
             ecolor='lightgray', elinewidth=3, capsize=0)

# Here's an example with a continuously estimated error bar
# Don't worry about the details on the modeling just yet

from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF

# define the model and draw some data
model = lambda x: x * np.sin(x)
xdata = np.array([1, 3, 5, 6, 8])
ydata = model(xdata)

# Compute the Gaussian process fit
gp = GaussianProcessRegressor(kernel=RBF())
gp.fit(xdata[:, np.newaxis], ydata)

xfit = np.linspace(0, 10, 1000)
yfit, MSE = gp.predict(xfit[:, np.newaxis], return_std=True)
dyfit = 2 * np.sqrt(MSE)  # 2*sigma ~ 95% confidence region

# Visualize the result
plt.plot(xdata, ydata, 'or')
plt.plot(xfit, yfit, '-', color='gray')

plt.fill_between(xfit, yfit - dyfit, yfit + dyfit,
                 color='gray', alpha=0.2)
plt.xlim(0, 10)

"""### Contour plots"""

# A three-dimensional function z = f(x, y)
def f(x, y):
    return np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)

x = np.linspace(0, 5, 50)
y = np.linspace(0, 5, 40)

# Question for you: What does np.meshgrid do here?
X, Y = np.meshgrid(x, y)
Z = f(X, Y)

# Make a contour plot
plt.contour(X, Y, Z, colors='black')

# plot as "filled" contour plt.contourf
# Change the number of bins to "20"
# change the colormap, show colorbar
# see: https://matplotlib.org/stable/tutorials/colors/colormaps.html
plt.contourf(X, Y, Z, 20, cmap='RdGy')
plt.colorbar()

# imshow() can display two-dimensional array data like images
# here, we specify extent since imshow() can't deal with X, Y data
plt.imshow(Z, extent=[0, 5, 0, 5], origin='lower',
           cmap='RdGy')
plt.colorbar()
plt.axis(aspect='image')

# A nicely labeled contour plot overlayed on an imshow image
contours = plt.contour(X, Y, Z, 3, colors='black')
plt.clabel(contours, inline=True, fontsize=8)

plt.imshow(Z, extent=[0, 5, 0, 5], origin='lower',
           cmap='RdGy', alpha=0.5)
plt.colorbar()

"""### Histograms"""

# a simple histogram using samples from a normal distribution
data = np.random.randn(1000)
plt.hist(data)

# a customized histogram
plt.hist(data, bins=30, alpha=0.5, density=True,
         histtype='stepfilled', color='steelblue',
         edgecolor='none')

# plotting multiple histograms
x1 = np.random.normal(0, 0.8, 1000)
x2 = np.random.normal(-2, 1, 1000)
x3 = np.random.normal(3, 2, 1000)

kwargs = dict(histtype='stepfilled', alpha=0.3, density=True, bins=40)

plt.hist(x1, **kwargs)
plt.hist(x2, **kwargs)
plt.hist(x3, **kwargs)

# plotting a 2-D histogram
mean = [0, 0]
cov = [[1, 1], [1, 2]]
x, y = np.random.multivariate_normal(mean, cov, 10000).T
plt.hist2d(x, y, bins=30, cmap='Blues')
cb = plt.colorbar()
cb.set_label('counts in bin')

"""### Subplots"""

# adding a subplot one-by-one
fig = plt.figure()
ax1 = fig.add_axes([0.1, 0.5, 0.8, 0.4],
                   xticklabels=[], ylim=(-1.2, 1.2))
ax2 = fig.add_axes([0.1, 0.1, 0.8, 0.4],
                   ylim=(-1.2, 1.2))

x = np.linspace(0, 10)
ax1.plot(np.sin(x))
ax2.plot(np.cos(x))

# setting up a subplot grid with plt.subplots
fig, ax = plt.subplots(2, 3, sharex='col', sharey='row')
# axes are in a two-dimensional array, indexed by [row, col]
for i in range(2):
    for j in range(3):
        ax[i, j].text(0.5, 0.5, str((i, j)),
                      fontsize=18, ha='center')

# to create subplots that span multiple rows and columns, use plt.GridSpec()
grid = plt.GridSpec(2, 3, wspace=0.4, hspace=0.3)
plt.subplot(grid[0, 0])
plt.subplot(grid[0, 1:])
plt.subplot(grid[1, :2])
plt.subplot(grid[1, 2])

# example of GridSpec showing a 2-d normal distribution histogram
# Create some normally distributed data
mean = [0, 0]
cov = [[1, 1], [1, 2]]
x, y = np.random.multivariate_normal(mean, cov, 3000).T

# Set up the axes with gridspec
fig = plt.figure(figsize=(6, 6))
grid = plt.GridSpec(4, 4, hspace=0.2, wspace=0.2)
main_ax = fig.add_subplot(grid[:-1, 1:])
y_hist = fig.add_subplot(grid[:-1, 0], xticklabels=[], sharey=main_ax)
x_hist = fig.add_subplot(grid[-1, 1:], yticklabels=[], sharex=main_ax)

# scatter points on the main axes
main_ax.plot(x, y, 'ok', markersize=3, alpha=0.2)

# histogram on the attached axes
x_hist.hist(x, 40, histtype='stepfilled',
            orientation='vertical', color='gray')
x_hist.invert_yaxis()

y_hist.hist(y, 40, histtype='stepfilled',
            orientation='horizontal', color='gray')
y_hist.invert_xaxis()

"""### Text and annotation

Here's an example demonstrating text annotation on top of a chart showing US births by day of the year
"""

!wget https://raw.githubusercontent.com/jakevdp/data-CDCbirths/master/births.csv

births = pd.read_csv('births.csv')

quartiles = np.percentile(births['births'], [25, 50, 75])
mu, sig = quartiles[1], 0.74 * (quartiles[2] - quartiles[0])
births = births.query('(births > @mu - 5 * @sig) & (births < @mu + 5 * @sig)')

births['day'] = births['day'].astype(int)

births.index = pd.to_datetime(10000 * births.year +
                              100 * births.month +
                              births.day, format='%Y%m%d')
births_by_date = births.pivot_table('births',
                                    [births.index.month, births.index.day])
births_by_date.index = [pd.datetime(2012, month, day)
                        for (month, day) in births_by_date.index]

import matplotlib as mpl

fig, ax = plt.subplots(figsize=(12, 4))
births_by_date.plot(ax=ax)

# Add labels to the plot
style = dict(size=10, color='gray')

ax.text('2012-1-1', 3950, "New Year's Day", **style)
ax.text('2012-7-4', 4250, "Independence Day", ha='center', **style)
ax.text('2012-9-4', 4850, "Labor Day", ha='center', **style)
ax.text('2012-10-31', 4600, "Halloween", ha='right', **style)
ax.text('2012-11-25', 4450, "Thanksgiving", ha='center', **style)
ax.text('2012-12-25', 3850, "Christmas ", ha='right', **style)

# Label the axes
ax.set(title='USA births by day of year (1969-1988)',
       ylabel='average daily births')

# Format the x axis with centered month labels
ax.xaxis.set_major_locator(mpl.dates.MonthLocator())
ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday=15))
ax.xaxis.set_major_formatter(plt.NullFormatter())
ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter('%h'))

# once again, this time using arrows!
fig, ax = plt.subplots(figsize=(12, 4))
births_by_date.plot(ax=ax)

# Add labels to the plot
ax.annotate("New Year's Day", xy=('2012-1-1', 4100),  xycoords='data',
            xytext=(50, -30), textcoords='offset points',
            arrowprops=dict(arrowstyle="->",
                            connectionstyle="arc3,rad=-0.2"))

ax.annotate("Independence Day", xy=('2012-7-4', 4250),  xycoords='data',
            bbox=dict(boxstyle="round", fc="none", ec="gray"),
            xytext=(10, -40), textcoords='offset points', ha='center',
            arrowprops=dict(arrowstyle="->"))

ax.annotate('Labor Day', xy=('2012-9-4', 4850), xycoords='data', ha='center',
            xytext=(0, -20), textcoords='offset points')
ax.annotate('', xy=('2012-9-1', 4850), xytext=('2012-9-7', 4850),
            xycoords='data', textcoords='data',
            arrowprops={'arrowstyle': '|-|,widthA=0.2,widthB=0.2', })

ax.annotate('Halloween', xy=('2012-10-31', 4600),  xycoords='data',
            xytext=(-80, -40), textcoords='offset points',
            arrowprops=dict(arrowstyle="fancy",
                            fc="0.6", ec="none",
                            connectionstyle="angle3,angleA=0,angleB=-90"))

ax.annotate('Thanksgiving', xy=('2012-11-25', 4500),  xycoords='data',
            xytext=(-120, -60), textcoords='offset points',
            bbox=dict(boxstyle="round4,pad=.5", fc="0.9"),
            arrowprops=dict(arrowstyle="->",
                            connectionstyle="angle,angleA=0,angleB=80,rad=20"))


ax.annotate('Christmas', xy=('2012-12-25', 3850),  xycoords='data',
             xytext=(-30, 0), textcoords='offset points',
             size=13, ha='right', va="center",
             bbox=dict(boxstyle="round", alpha=0.1),
             arrowprops=dict(arrowstyle="wedge,tail_width=0.5", alpha=0.1));

# Label the axes
ax.set(title='USA births by day of year (1969-1988)',
       ylabel='average daily births')

# Format the x axis with centered month labels
ax.xaxis.set_major_locator(mpl.dates.MonthLocator())
ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday=15))
ax.xaxis.set_major_formatter(plt.NullFormatter())
ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter('%h'));

ax.set_ylim(3600, 5400)